# 面试题

## 前端为什么要进行打包和构建

代码处理

1. 体积更小（Tree-Shaking、压缩，合并），加载更快
2. 编译高级语言或语法（TS,ES6+，模块化，SCSS）
3. 兼容性和错误检查（polyfill， postcss, eslint）

前端工程化

1. 统一、高效的开发环境
2. 统一的构建和产出标准
3. 继承公司构建规范（提测、上线等）

## moudle chunk bundle 的区别

moudle 各个源码文件

chunk 多模块合并成 

bundle 输出结果

## loader和plugin的区别

loader模块转化器 如less->css webpack官网的loader

plugin 扩展插件 htmlWebpackPlugin webpack官网的plugin

## babel 和 webpack的区别

babel - JS新语法编译工具，不关心模块化

webpack - 打包构建工具，多个loader和plugin集合

## 产出一个lib

参考 webpack.dll.js

output.library

## babel-polyfill 和 babel-runtime的区别

babel-polyfill 污染全局

babel-runtime 不会污染群居

第三方产 lib 要用babel-runtime

## webpack懒加载

import()

Vue 和 React 异步组件

VueRouter 和 ReactRouter 异步加载路由

## Proxy不能被Polyfill

Class 可以用 function 模拟

Promise 可以用callback 模拟

但是Proxy 不能用defineProperty 模拟

## webpack 优化构建速度

可用于生产环境

1. babel-laoder优化
2. IgnorePlugin 忽略某些文件
3. noParse
3. happyPack
4. ParallelUglifyPlugin

不可用于生产环境

1. 自动刷新
2. 热更新
3. DllPlugin

## webpack 优化产出代码

1. 小图片base64编码
2. bundle hash
3.  懒加载
4. 提取公共代码
5. IgnorePlugin
6.  使用CDN加速
7. 使用production模式
8.  使用Scope Hosting
