# 调试和工作流

## loader和plugin的区别

loader 用于webpack解析非js文件，比如css，图片等的能力

plugin 用于拓展webpack的能力，比如htmlWebpackPlugin，可以在其生命周期中监听事件更改构建结果

## webpack构建流程

这个过程中，webpack会触发对应的钩子函数

### 1. 初始化参数

从配置文件和Shell语句中读取和合并参数，得出最终的参数

### 2. 开始编译

使用上一步的参数初始化Compiler对象，加载所有的配置插件，执行对象run方法开始编译

确定入口： 根据配置中的entry找出所有入口文件

### 3. 编译模块

入口出发，对所有配置的Loader对模块进行编译，再找出该模块的依赖的模块

1. 获取文件路径entry
2. 通过entry读取模块内容entryContent
3. 调用babelLoader获取entryContent转化结果entrySource
4. 生成entryModule对象，并设置模块的id和source，然后推入modules中

### 4. 完成模块编译

使用loader翻译完所有的模块后，得到每一个模块被翻译后的最终内容和他们的依赖关系

根据入口和模块的依赖关系组成一个chunk，再把每个Chunk转化成一个单独的文件加入到输出列表中

这里是修改输出内容的最后机会

### 5. 输出完成

确定好输出内容后，确定输出的路径和文件名，把文件内容写入到文件系统中

### 构建流程大致逻辑代码

```js
class Compiler {
    constructor(options) {
        this.options = options;
        this.hooks = {
            run: new SyncHook(),
            done: new SyncHook(),
        }
    }

    run() {
        let modules = [];
        let chunks = [];
        let files = [];

        this.hooks.run.call(); // 触发run事件
        let entry = path.join(this.options.context, this.options.entry); // 获取入口文件
        let entryContent = fs.readFileSync(entry, 'utf-8') // 读取入口文件内容
        let entrySource = babelLoader(entryContent); // 调用babel-loader
        // 模块module chunk代码快 file bundle 文件关系
        let entryModule = {
            id: entry,
            source: entrySource
        };
        modules.push(entryModule);

        // 入口模块代码转成抽象语法树AST,分析里面import和require的关系
        let title = path.join(this.options.context, './src/title.js'); // title模块获取
        let titleContent = fs.readFileSync(title, 'utf-8') // 读取入口文件内容
        let titleSource = babelLoader(titleContent); // 调用babel-loader
        // 模块module chunk代码快 file bundle 文件关系
        let titleModule = {
            id: title,
            source: titleSource
        };
        modules.push(titleModule);

        // 根据入口和模块的依赖关系组成一个chunk
        let chunk = {
            name: 'main',
            modules: modules,
        };
        chunks.push(chunk);
        // 把chunk转化成一个单独的文件加入到输出列表中
        let file = {
            file: this.options.output.fileName,
            source: '打包源码',
        };
        files.push(file);
        // 确定好输出内容后，确定输出的路径和文件名，把文件内容写入到文件系统中
        let outputPath = path.join(this.options.output.path, this.options.output.fileName);
        fs.writeFileSync(outputPath, file.source, 'utf-8');

        this.hooks.done.call(); // 触发done事件
    }
}

let options = require('./webpack.config.js');
let compiler = new Compiler(options);
// 插件应用
if (options.plugins && Array.isArray(options.plugins)) {
    for (const plugin in options.plugins) {
        plugin.apply(compiler);
    }
}
// 编译执行
compiler.run();

function babelLoader(source) {
    return `
    编译结果
    `
}
```

### 简单插件钩子代码

```js
moudle.exports = class DonePlugin {
    apply(compiler) {
        // 注册完成钩子
        compiler.hooks.done.tap('DonePlugin', () => {
            console.log('打包完成');
        })
    }
}

moudle.exports = class RunPlugin {
    apply(compiler) {
        // 注册开始钩子
        compiler.hooks.run.tap('RunPlugin', () => {
            console.log('开始打包');
        })
    }
}
```
